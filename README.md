# **Next.js 13 정리 Repository**

## **설치 및 프로젝트 생성**

1. Node.js와 VSCode 설치 후 진행
2. 프로젝트 저장 할 폴더 생성
3. 프로젝트 생성 (npx 사용)

현재폴더의 nextjs의 개발환경을 만드는 명령어

```bash
npx create-next-app@latest .
#@는 버전을 설정
#.은 현재 폴더에서 진행하겠다를 의미
```

해당 명령어를 입력하면 밑에 질문들이 나오는데 해당 질문들은 원하는 프로젝트에 따라 변경해 주면 된다

```
✔ Would you like to use TypeScript? … No / Yes
✔ Would you like to use ESLint? … No / Yes
✔ Would you like to use Tailwind CSS? … No / Yes
✔ Would you like to use `src/` directory? … No / Yes
✔ Would you like to use App Router? (recommended) … No / Yes
✔ Would you like to customize the default import alias? … No / Yes
```

13버전 이전에는 Page Router를 사용했고  
13버전 이후에는 App Router를 사용함

## **프로젝트 실행**

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
```

## **샘플 앱 세탁**

### src/app/layout.js

웹 페이지의 골격을 구성함

```js
import "./globals.css";
import { Inter } from "next/font/google";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  );
}
```

해당 코드에서 불필요한 부분 제거

```js
import "./globals.css";

export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({ children }) {
  return (
    <html>
      <body>{children}</body>
    </html>
  );
}
```

### src/app/page.js

latout.js안에 {children}에 들어가는 부분  
이것도 역시 불필요한 코드를 제거

```js
import Image from "next/image";

export default function Home() {
  return <>Hello, Nextjs!</>;
}
```

### src/app/global.css

여기 스타일 또한 모두 제거하게 되면 개발할 준비가 완료되게 된다

## **배포**

### npm run build

실제 배포를 위한 배포판이 .next폴더가 생성됨

### npm run start

.next에 저장된 내용이 서비스 되기 시작함

## **ROUTING (라우팅)**

src/app 폴더 밑에 추가할 페이지 폴더를 생성
create폴더 생성 후 page.js 생성  
**page.js**

```js
export default function Create() {
  return <>Create</>;
}
```

이렇게 만들어주면 app폴더 안에 있는 layout.js의 children의 안에 들어가게 된다  
하지만 해당 페이지에서 또 반복되는 것이 있으면 create 폴더 내부에 layout.js를 생성

```js
export default function Layout(props) {
  return (
    <form>
      <h2>Create</h2>
      {props.children}
    </form>
  );
}
```

이렇게 함으로써 /create 주소를 갖는 페이지들의 공통 layout 생성 가능

### **동적 라우팅**

app폴더 내부의 layout.js를 살펴보면

```js

          <a href="/">WEB</a>
          <ol>
            <li>
              <a href="/read/1">html</a>
            </li>
            <li>
              <a href="/read/2">css</a>
            </li>
          </ol>
        {children}
        <ul>
          <li>
            <a href="/create">create</a>
          </li>
          <li>
            <a href="/update/1">update</a>
          </li>


```

이렇게 주소 뒤에 숫자가 나오는 경우 동적 라우팅을 한다  
똑같이 페이지의 폴더를 생성해주고  
그 안에 해당 파라미터의 명칭을 대괄호로 감싼 폴더를 만들어 주면 된다.

[id] 폴더 내부에 page.js를 생성  
해당 파라미터는 props.params를 통해 받을 수 있음

```js
export default function Read(props) {
  return (
    <>
      <h2>Read</h2>
      parameter : {props.params.id}
    </>
  );
}
```

## **SSR**

새로고침이나 다른 Url로 이동하면 새로운 페이지에 대한 정보를 서버에 요청하고 해당 페이지 내용을 서버로부터 받아와서 렌더링 시키는 방식  
검색 엔진 최적화에는 좋으나 페이지의 적은 부분이 바뀌어도 처음부터 전부 렌더링 하기 때문에 비용 증가 밎 느린 로딩이 단점

## **SPA**

최초 한번 페이지 전체를 로딩한 후부터 데이터만 변경해서 사용할 수 있는 웹 애플리케이션을 의미  
첫 로딩 시 전체 페이지를 로딩하기 때문에 초반 로딩 속도는 느릴 수 있으나 첫 로딩 후 페이지 전환이 빠로고 배포 하는 입장에서의 비용 절감 효과를 볼 수 있으나 SSR에 비해 검색 엔진 최적화에는 약함

## **Nextjs를 쓰는 이유**

Nextjs는 서버에서 리액트를 실행하여 그 결과를 .next폴더 내부에 Javascript가 아닌 html 형태로 저장하여 보여주기 때문에 SSR의 장점인 **SEO**(검색 엔진 최적화)에 이점이 있음  
SSR의 단점인 느린 속도와 이미 방문한 페이지를 방문할 떄 또 다시 렌더링 하는 문제를 Link 컴포넌트로 해결할 수 있음

Link컴포넌트를 hover하면 backgroundd에서 미리 페이지를 다운받아넣기 때문에 빠르게 렌더링 할 수 있음  
또한 이미 방문한 페이지를 방문하면 아예 서버와 통신하지 않아 SPA의 장점도 갖을 수 있다는 것임
